%
% TÍTULO DEL CAPÍTULO
%
\chapter{GCVL: GPU Computer Vision Library
	\label{chapter_3}
}

\textbf{GCVL} is a set of software tools and libraries that allow the user to run and implement common Computer Vision algorithms on modern GPUs. It comprises a set of OpenCL and CUDA tools, a Block Matching example algorithm implementation and base classes to implement custom algorithms.

\section{Development Methodology}

Agile software development \cite{agiledev} is a combination of development methods that use iterative and incremental development, where requirements and solutions mature through collaboration between self-organizing, cross-functional teams. The motto of this method is ``embrace change''; that is why it encourages adaptive planning, evolutionary development and delivery, a time-boxed iterative approach, and promotes quick and flexible response to change.

\subsection{Agile manifesto}

In February of 2001, several developers met at Snowbird, Utah resort, to debate different lightweight development methods. They published the \emph{Manifesto for Agile Software Development} \cite{agilemani} to define the approach that is now called agile software development. 

The conclusions that we can reach from the manifesto's items are described below:

\begin{itemize}
\item \textbf{Individuals and Interactions}: In agile development self-organization and motivation are really important. Other values promoted by the manifesto are co-location\footnote{The act of placing multiple individuals within a single location.} and pair programming\footnote{Two programmers work together at one workstation.}.
\item \textbf{Working software}: Working software will be utilized for more purposes than presenting documents to the client.
\item \textbf{Customer collaboration}: The software requirements cannot be fully realized from the beginning of the software development cycle, so being in touch with the customer is really important.
\item \textbf{Responding to change}: Agile development is keen on fast responses to change and continuous development.  
\end{itemize}

More principles are mentioned in the manifesto, some of them are:

\begin{itemize}
\item Customer satisfaction by rapid delivery of useful software.
\item Welcome changes even late in the development.
\item Working software is the principal measure of progress.
\item Maintaining a constant pace.
\item Cooperation between business people and developers. 
\item Build projects around motivated individuals.
\item Attention to technical excellence.
\item Simplicity.
\end{itemize}

Agile methods break down tasks into small increments with minimal planning and normally long-term planning is not directly involved. \emph{Iterations} are short timeframes that typically last from one to four weeks. A team works in each iteration through a full software development cycle; including planning, requirements analysis, design, coding, etc. This minimizes risk and facilitates adaptation to change. An iteration may not add enough new functionalities to warrant a market release, but the objective is to have an available release at the end of each iteration. 

Team composition does not depend on corporate hierarchies or corporate roles of team members. They normally have the responsability of completing tasks that deliver the required functionalities that an iteration requires. How to meet an iteration's objectives is decided individually.

The ``weight'' of the method depends on the type of project, the planning and order of tasks in a generalist project should not be the same as in a research project.  

Agile methods encourage face-to-face communication instead of written documents if possible. Most teams work in an open office (the \emph{bullpen}), which makes this type of communication easier. 

Each agile team contains a customer representative, that ensures that customer needs and company goals are aligned. 

Most agile methods encourage a routine that includes daily face-to-face communication among team members. In a brief session team members tell each other what they achieved the previous day, what they are going to do today and the problems that have appeared. 

As agile development emphasizes on working software as the primary measure of progress and has a clear preference in face-to-face communication this results in less written documentation than other methods. This does not mean that documentation should be disregarded, but that less emphasis is made on documentation because is not needed as much.

\section{Technology}

%TODO complete
Tecnologia usada?

\section{Design}

GCVL is developed following an object oriented approach and using the \CC programming language. For GPGPU programming we have chosen OpenCL and CUDA, because of their inter-operation capabilities with OpenGL. This will allow us to process directly data that already resides in the GPU, without having to do expensive memory transfers. Because of the open nature of OpenCL, the software will be able to run on any graphics card vendor (AMD, NVIDIA or Intel) and the SO that the user prefers (Windows, OSX or Unix). For NVIDIA GPUs we have also developed a CUDA implementation, this way users will be able to squish the maximum amount of performance out of the green team's devices. Design patterns have been used as much as possible. This section briefly depicts the high-level design of GCVL in the form of class diagrams.

\subsection{Class diagram}

The high-level design of the \textbf{GCVL} library is depicted in the class diagram of \autoref{class_diag}. In this design, the \textbf{General Tools} module contains utility classes that contain commonly used functions and configuration parameters. In addition, the \textbf{CPU} module contains tools to implement multi-core CPU algorithms using GCVL, examples, template classes, etc.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.73]{figures/GCVL.pdf}
	\caption{GCVL class diagram.} \label{class_diag}
\end{figure}

Furthermore, the \textbf{OpenCL} module contains classes related to the development of OpenCL algorithms (tools, example algorithms, kernels, etc.).

Finally, the \textbf{CUDA} module resembles the aforementioned module, containing tools, algorithm examples, kernels, etc. It possesses all the classes that are needed to implement CUDA programs in a simple manner.

All of the GPU modules present in GCVL can be compiled on demand using CMake options, so if the CUDA framework or the OpenCL libraries are not needed, they can be deactivated and the rest of the library can be used without any kind of issue.

\subsection{General Tools}

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.73]{figures/general_tools.pdf}
	\caption{General Tools module class diagram.} \label{general_tools}
\end{figure} 

In the diagram of \autoref{general_tools}, the following classes are the most relevant:

\begin{itemize}
	\item \textbf{GCVLConfig:} This class contains the configuration parameters present in GCVL. For example, the suppression of warnings, constant definitions, etc. 
	\item \textbf{GCVLTools:} Class that contains utility functions used in all the modules present in GCVL, be it CPU or GPU modules. 
\end{itemize}

\subsection{CPU Module}

\begin{itemize}
	\item \textbf{Algorithm:} This base class contains the template for the implementation  of multi-core CPU algorithms in GCVL.
	\item \textbf{BlockMatching:} This class serves as an example of the implementation of a multi-core CPU algorithm in GCVL. 
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.73]{figures/cpu_module.pdf}
	\caption{CPU module class diagram.} \label{general_tools}
\end{figure} 

\subsection{OpenCL Module}

opencl

\subsection{CUDA Module}

cuda


